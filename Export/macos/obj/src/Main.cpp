// Generated by Haxe 4.3.7
#include <hxcpp.h>

#ifndef INCLUDED_Main
#include <Main.h>
#endif
#ifndef INCLUDED_StringTools
#include <StringTools.h>
#endif
#ifndef INCLUDED_controllers_DataController
#include <controllers/DataController.h>
#endif
#ifndef INCLUDED_haxe_IMap
#include <haxe/IMap.h>
#endif
#ifndef INCLUDED_haxe_Log
#include <haxe/Log.h>
#endif
#ifndef INCLUDED_haxe_ds_StringMap
#include <haxe/ds/StringMap.h>
#endif
#ifndef INCLUDED_haxe_io_Path
#include <haxe/io/Path.h>
#endif
#ifndef INCLUDED_hxSerial_Serial
#include <hxSerial/Serial.h>
#endif
#ifndef INCLUDED_hxvlc_openfl_Video
#include <hxvlc/openfl/Video.h>
#endif
#ifndef INCLUDED_lime_app_IModule
#include <lime/app/IModule.h>
#endif
#ifndef INCLUDED_lime_app__Event_Void_Void
#include <lime/app/_Event_Void_Void.h>
#endif
#ifndef INCLUDED_lime_system_System
#include <lime/system/System.h>
#endif
#ifndef INCLUDED_openfl_display_Bitmap
#include <openfl/display/Bitmap.h>
#endif
#ifndef INCLUDED_openfl_display_BitmapData
#include <openfl/display/BitmapData.h>
#endif
#ifndef INCLUDED_openfl_display_DisplayObject
#include <openfl/display/DisplayObject.h>
#endif
#ifndef INCLUDED_openfl_display_DisplayObjectContainer
#include <openfl/display/DisplayObjectContainer.h>
#endif
#ifndef INCLUDED_openfl_display_IBitmapDrawable
#include <openfl/display/IBitmapDrawable.h>
#endif
#ifndef INCLUDED_openfl_display_InteractiveObject
#include <openfl/display/InteractiveObject.h>
#endif
#ifndef INCLUDED_openfl_display_NativeWindow
#include <openfl/display/NativeWindow.h>
#endif
#ifndef INCLUDED_openfl_display_Sprite
#include <openfl/display/Sprite.h>
#endif
#ifndef INCLUDED_openfl_display_Stage
#include <openfl/display/Stage.h>
#endif
#ifndef INCLUDED_openfl_events_Event
#include <openfl/events/Event.h>
#endif
#ifndef INCLUDED_openfl_events_EventDispatcher
#include <openfl/events/EventDispatcher.h>
#endif
#ifndef INCLUDED_openfl_events_IEventDispatcher
#include <openfl/events/IEventDispatcher.h>
#endif
#ifndef INCLUDED_openfl_events_KeyboardEvent
#include <openfl/events/KeyboardEvent.h>
#endif
#ifndef INCLUDED_openfl_text_TextField
#include <openfl/text/TextField.h>
#endif
#ifndef INCLUDED_openfl_text_TextFormat
#include <openfl/text/TextFormat.h>
#endif

HX_DEFINE_STACK_FRAME(_hx_pos_e47a9afac0942eb9_19_new,"Main","new",0x6616a5cb,"Main.new","Main.hx",19,0x087e5c05)
HX_LOCAL_STACK_FRAME(_hx_pos_e47a9afac0942eb9_59_initSerial,"Main","initSerial",0x09fa4319,"Main.initSerial","Main.hx",59,0x087e5c05)
HX_LOCAL_STACK_FRAME(_hx_pos_e47a9afac0942eb9_67_initText,"Main","initText",0x98b9a292,"Main.initText","Main.hx",67,0x087e5c05)
HX_LOCAL_STACK_FRAME(_hx_pos_e47a9afac0942eb9_86_initVideo,"Main","initVideo",0x331766f6,"Main.initVideo","Main.hx",86,0x087e5c05)
HX_LOCAL_STACK_FRAME(_hx_pos_e47a9afac0942eb9_90_initVideo,"Main","initVideo",0x331766f6,"Main.initVideo","Main.hx",90,0x087e5c05)
HX_LOCAL_STACK_FRAME(_hx_pos_e47a9afac0942eb9_101_initVideo,"Main","initVideo",0x331766f6,"Main.initVideo","Main.hx",101,0x087e5c05)
HX_LOCAL_STACK_FRAME(_hx_pos_e47a9afac0942eb9_84_initVideo,"Main","initVideo",0x331766f6,"Main.initVideo","Main.hx",84,0x087e5c05)
HX_LOCAL_STACK_FRAME(_hx_pos_e47a9afac0942eb9_109_stage_onEnterFrame,"Main","stage_onEnterFrame",0x47166a4a,"Main.stage_onEnterFrame","Main.hx",109,0x087e5c05)
HX_LOCAL_STACK_FRAME(_hx_pos_e47a9afac0942eb9_128_stage_onKeyDown,"Main","stage_onKeyDown",0xfd7eec2c,"Main.stage_onKeyDown","Main.hx",128,0x087e5c05)
HX_LOCAL_STACK_FRAME(_hx_pos_e47a9afac0942eb9_142_traceSerialDevices,"Main","traceSerialDevices",0xc5a318b9,"Main.traceSerialDevices","Main.hx",142,0x087e5c05)
HX_LOCAL_STACK_FRAME(_hx_pos_e47a9afac0942eb9_153_stage_onActivate,"Main","stage_onActivate",0x9506d2c8,"Main.stage_onActivate","Main.hx",153,0x087e5c05)
HX_LOCAL_STACK_FRAME(_hx_pos_e47a9afac0942eb9_160_stage_onDeactivate,"Main","stage_onDeactivate",0x80c7c289,"Main.stage_onDeactivate","Main.hx",160,0x087e5c05)
HX_LOCAL_STACK_FRAME(_hx_pos_e47a9afac0942eb9_167_connectSerialPortByIndex,"Main","connectSerialPortByIndex",0x6b829811,"Main.connectSerialPortByIndex","Main.hx",167,0x087e5c05)
HX_LOCAL_STACK_FRAME(_hx_pos_e47a9afac0942eb9_190_connectSerialPortByPath,"Main","connectSerialPortByPath",0xfe2ecd86,"Main.connectSerialPortByPath","Main.hx",190,0x087e5c05)
HX_LOCAL_STACK_FRAME(_hx_pos_e47a9afac0942eb9_213_nextPort,"Main","nextPort",0x3d31d0c9,"Main.nextPort","Main.hx",213,0x087e5c05)
HX_LOCAL_STACK_FRAME(_hx_pos_e47a9afac0942eb9_224_previousPort,"Main","previousPort",0x17d8f88d,"Main.previousPort","Main.hx",224,0x087e5c05)
HX_LOCAL_STACK_FRAME(_hx_pos_e47a9afac0942eb9_238_parseSerial,"Main","parseSerial",0xe870cef2,"Main.parseSerial","Main.hx",238,0x087e5c05)
HX_LOCAL_STACK_FRAME(_hx_pos_e47a9afac0942eb9_266_playVideoByTag,"Main","playVideoByTag",0x8a67c1d1,"Main.playVideoByTag","Main.hx",266,0x087e5c05)

void Main_obj::__construct(){
            	HX_STACKFRAME(&_hx_pos_e47a9afac0942eb9_19_new)
HXLINE(  38)		this->ffmpegAvailable = false;
HXLINE(  31)		this->tagTriggerDebounce = 2000;
HXLINE(  30)		this->tagStartTime = 0;
HXLINE(  28)		this->doVideoUpdate = false;
HXLINE(  25)		this->serialBuffer = HX_("",00,00,00,00);
HXLINE(  24)		this->serialPortIndex = 0;
HXLINE(  23)		this->serialConnected = false;
HXLINE(  21)		this->deviceList = ::Array_obj< ::String >::__new(0);
HXLINE(  44)		super::__construct();
HXLINE(  46)		::controllers::DataController_obj::loadConfig();
HXLINE(  48)		this->stage->addEventListener(HX_("enterFrame",f5,03,50,02),this->stage_onEnterFrame_dyn(),null(),null(),null());
HXLINE(  49)		this->stage->addEventListener(HX_("keyDown",a1,69,47,9c),this->stage_onKeyDown_dyn(),null(),null(),null());
HXLINE(  51)		this->initText();
HXLINE(  52)		this->initSerial();
HXLINE(  53)		this->initVideo();
            	}

Dynamic Main_obj::__CreateEmpty() { return new Main_obj; }

void *Main_obj::_hx_vtable = 0;

Dynamic Main_obj::__Create(::hx::DynamicArray inArgs)
{
	::hx::ObjectPtr< Main_obj > _hx_result = new Main_obj();
	_hx_result->__construct();
	return _hx_result;
}

bool Main_obj::_hx_isInstanceOf(int inClassId) {
	if (inClassId<=(int)0x0c89e854) {
		if (inClassId<=(int)0x07825a7d) {
			if (inClassId<=(int)0x0330636f) {
				return inClassId==(int)0x00000001 || inClassId==(int)0x0330636f;
			} else {
				return inClassId==(int)0x07825a7d;
			}
		} else {
			return inClassId==(int)0x0c89e854;
		}
	} else {
		if (inClassId<=(int)0x4af7dd8e) {
			return inClassId==(int)0x1f4df417 || inClassId==(int)0x4af7dd8e;
		} else {
			return inClassId==(int)0x6b353933;
		}
	}
}

void Main_obj::initSerial(){
            	HX_STACKFRAME(&_hx_pos_e47a9afac0942eb9_59_initSerial)
HXLINE(  60)		this->storedPortPath = ::haxe::io::Path_obj::join(::Array_obj< ::String >::__new(2)->init(0,::lime::_hx_system::System_obj::get_applicationStorageDirectory())->init(1,HX_("port.txt",03,17,cb,8b)));
HXLINE(  61)		this->connectSerialPortByIndex(( (int)(::controllers::DataController_obj::data->__Field(HX_("portIndex",d1,33,b4,4d),::hx::paccDynamic)) ));
            	}


HX_DEFINE_DYNAMIC_FUNC0(Main_obj,initSerial,(void))

void Main_obj::initText(){
            	HX_GC_STACKFRAME(&_hx_pos_e47a9afac0942eb9_67_initText)
HXLINE(  68)		this->statusText =  ::openfl::text::TextField_obj::__alloc( HX_CTX );
HXLINE(  69)		 ::openfl::text::TextField _hx_tmp = this->statusText;
HXDLIN(  69)		_hx_tmp->set_defaultTextFormat( ::openfl::text::TextFormat_obj::__alloc( HX_CTX ,HX_("_sans",32,a0,5e,ff),11,16777215,null(),null(),null(),null(),null(),null(),null(),null(),null(),null()));
HXLINE(  70)		this->statusText->set_embedFonts(true);
HXLINE(  71)		this->statusText->set_antiAliasType(0);
HXLINE(  72)		this->statusText->set_gridFitType(1);
HXLINE(  73)		this->statusText->set_width(( (Float)(240) ));
HXLINE(  74)		this->statusText->set_height(( (Float)(100) ));
HXLINE(  75)		this->statusText->set_selectable(false);
HXLINE(  76)		this->statusText->mouseEnabled = false;
HXLINE(  77)		this->statusText->set_text(HX_("",00,00,00,00));
HXLINE(  78)		this->addChild(this->statusText);
            	}


HX_DEFINE_DYNAMIC_FUNC0(Main_obj,initText,(void))

void Main_obj::initVideo(){
            		HX_BEGIN_LOCAL_FUNC_S1(::hx::LocalFunc,_hx_Closure_0, ::Main,_gthis) HXARGC(0)
            		void _hx_run(){
            			HX_GC_STACKFRAME(&_hx_pos_e47a9afac0942eb9_86_initVideo)
HXLINE(  87)			_gthis->stage->nativeWindow->addEventListener(HX_("activate",b3,1b,ac,e5),_gthis->stage_onActivate_dyn(),null(),null(),null());
HXLINE(  88)			_gthis->stage->nativeWindow->addEventListener(HX_("deactivate",34,5c,01,3c),_gthis->stage_onDeactivate_dyn(),null(),null(),null());
            		}
            		HX_END_LOCAL_FUNC0((void))

            		HX_BEGIN_LOCAL_FUNC_S1(::hx::LocalFunc,_hx_Closure_1, ::Main,_gthis) HXARGC(0)
            		void _hx_run(){
            			HX_GC_STACKFRAME(&_hx_pos_e47a9afac0942eb9_90_initVideo)
HXLINE(  91)			_gthis->stage->nativeWindow->removeEventListener(HX_("activate",b3,1b,ac,e5),_gthis->stage_onActivate_dyn(),null());
HXLINE(  92)			_gthis->stage->nativeWindow->removeEventListener(HX_("deactivate",34,5c,01,3c),_gthis->stage_onDeactivate_dyn(),null());
HXLINE(  93)			_gthis->doVideoUpdate = false;
HXLINE(  94)			if (::hx::IsNotNull( _gthis->video )) {
HXLINE(  95)				_gthis->removeChild(_gthis->video);
HXLINE(  96)				_gthis->video->dispose();
HXLINE(  97)				_gthis->video = null();
            			}
            		}
            		HX_END_LOCAL_FUNC0((void))

            		HX_BEGIN_LOCAL_FUNC_S1(::hx::LocalFunc,_hx_Closure_2, ::Main,_gthis) HXARGC(0)
            		void _hx_run(){
            			HX_GC_STACKFRAME(&_hx_pos_e47a9afac0942eb9_101_initVideo)
HXLINE( 101)			_gthis->doVideoUpdate = true;
            		}
            		HX_END_LOCAL_FUNC0((void))

            	HX_GC_STACKFRAME(&_hx_pos_e47a9afac0942eb9_84_initVideo)
HXDLIN(  84)		 ::Main _gthis = ::hx::ObjectPtr<OBJ_>(this);
HXLINE(  85)		this->video =  ::hxvlc::openfl::Video_obj::__alloc( HX_CTX ,null());
HXLINE(  86)		this->video->onOpening->add( ::Dynamic(new _hx_Closure_0(_gthis)),null(),null());
HXLINE(  90)		this->video->onEndReached->add( ::Dynamic(new _hx_Closure_1(_gthis)),null(),null());
HXLINE( 100)		this->video->onFormatSetup->add( ::Dynamic(new _hx_Closure_2(_gthis)),null(),null());
HXLINE( 103)		this->addChild(this->video);
            	}


HX_DEFINE_DYNAMIC_FUNC0(Main_obj,initVideo,(void))

void Main_obj::stage_onEnterFrame( ::openfl::events::Event event){
            	HX_STACKFRAME(&_hx_pos_e47a9afac0942eb9_109_stage_onEnterFrame)
HXLINE( 110)		this->parseSerial();
HXLINE( 112)		if (this->doVideoUpdate) {
HXLINE( 113)			bool _hx_tmp;
HXDLIN( 113)			if (::hx::IsNotNull( this->video )) {
HXLINE( 113)				_hx_tmp = ::hx::IsNotNull( this->video->get_bitmapData() );
            			}
            			else {
HXLINE( 113)				_hx_tmp = false;
            			}
HXDLIN( 113)			if (_hx_tmp) {
HXLINE( 114)				int aspectRatio = this->video->get_bitmapData()->width;
HXDLIN( 114)				Float aspectRatio1 = (( (Float)(aspectRatio) ) / ( (Float)(this->video->get_bitmapData()->height) ));
HXLINE( 116)				Float _hx_tmp1;
HXDLIN( 116)				if (((( (Float)(this->stage->stageWidth) ) / ( (Float)(this->stage->stageHeight) )) > aspectRatio1)) {
HXLINE( 116)					_hx_tmp1 = (( (Float)(this->stage->stageHeight) ) * aspectRatio1);
            				}
            				else {
HXLINE( 116)					_hx_tmp1 = ( (Float)(this->stage->stageWidth) );
            				}
HXDLIN( 116)				this->video->set_width(_hx_tmp1);
HXLINE( 117)				Float _hx_tmp2;
HXDLIN( 117)				if (((( (Float)(this->stage->stageWidth) ) / ( (Float)(this->stage->stageHeight) )) > aspectRatio1)) {
HXLINE( 117)					_hx_tmp2 = ( (Float)(this->stage->stageHeight) );
            				}
            				else {
HXLINE( 117)					_hx_tmp2 = (( (Float)(this->stage->stageWidth) ) / aspectRatio1);
            				}
HXDLIN( 117)				this->video->set_height(_hx_tmp2);
HXLINE( 118)				 ::hxvlc::openfl::Video _hx_tmp3 = this->video;
HXDLIN( 118)				int _hx_tmp4 = this->stage->stageWidth;
HXDLIN( 118)				_hx_tmp3->set_x(((( (Float)(_hx_tmp4) ) - this->video->get_width()) / ( (Float)(2) )));
HXLINE( 119)				 ::hxvlc::openfl::Video _hx_tmp5 = this->video;
HXDLIN( 119)				int _hx_tmp6 = this->stage->stageHeight;
HXDLIN( 119)				_hx_tmp5->set_y(((( (Float)(_hx_tmp6) ) - this->video->get_height()) / ( (Float)(2) )));
            			}
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC1(Main_obj,stage_onEnterFrame,(void))

void Main_obj::stage_onKeyDown( ::openfl::events::KeyboardEvent e){
            	HX_STACKFRAME(&_hx_pos_e47a9afac0942eb9_128_stage_onKeyDown)
HXDLIN( 128)		switch((int)(e->keyCode)){
            			case (int)68: {
HXLINE( 134)				this->traceSerialDevices();
            			}
            			break;
            			case (int)188: {
HXLINE( 130)				if (e->commandKey) {
HXLINE( 131)					::controllers::DataController_obj::openConfigJson();
            				}
            			}
            			break;
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC1(Main_obj,stage_onKeyDown,(void))

void Main_obj::traceSerialDevices(){
            	HX_STACKFRAME(&_hx_pos_e47a9afac0942eb9_142_traceSerialDevices)
HXDLIN( 142)		bool _hx_tmp;
HXDLIN( 142)		if (::hx::IsNotNull( this->deviceList )) {
HXDLIN( 142)			_hx_tmp = (this->deviceList->length > 0);
            		}
            		else {
HXDLIN( 142)			_hx_tmp = false;
            		}
HXDLIN( 142)		if (_hx_tmp) {
HXLINE( 143)			int _g = 0;
HXDLIN( 143)			int _g1 = (this->deviceList->length - 1);
HXDLIN( 143)			while((_g < _g1)){
HXLINE( 143)				_g = (_g + 1);
HXDLIN( 143)				int j = (_g - 1);
HXLINE( 144)				::haxe::Log_obj::trace(j, ::Dynamic(::hx::Anon_obj::Create(5)
            					->setFixed(0,HX_("className",a3,92,3d,dc),HX_("Main",59,64,2f,33))
            					->setFixed(1,HX_("customParams",d7,51,18,ed),::cpp::VirtualArray_obj::__new(1)->init(0,this->deviceList->__get(j)))
            					->setFixed(2,HX_("methodName",cc,19,0f,12),HX_("traceSerialDevices",c4,1d,cd,0d))
            					->setFixed(3,HX_("fileName",e7,5a,43,62),HX_("Source/Main.hx",b1,67,fd,ea))
            					->setFixed(4,HX_("lineNumber",dd,81,22,76),144)));
            			}
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC0(Main_obj,traceSerialDevices,(void))

void Main_obj::stage_onActivate( ::openfl::events::Event event){
            	HX_STACKFRAME(&_hx_pos_e47a9afac0942eb9_153_stage_onActivate)
HXDLIN( 153)		 ::hxvlc::openfl::Video tmp = this->video;
HXDLIN( 153)		if (::hx::IsNotNull( tmp )) {
HXDLIN( 153)			tmp->resume();
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC1(Main_obj,stage_onActivate,(void))

void Main_obj::stage_onDeactivate( ::openfl::events::Event event){
            	HX_STACKFRAME(&_hx_pos_e47a9afac0942eb9_160_stage_onDeactivate)
HXDLIN( 160)		 ::hxvlc::openfl::Video tmp = this->video;
HXDLIN( 160)		if (::hx::IsNotNull( tmp )) {
HXDLIN( 160)			tmp->pause();
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC1(Main_obj,stage_onDeactivate,(void))

void Main_obj::connectSerialPortByIndex(int i){
            	HX_GC_STACKFRAME(&_hx_pos_e47a9afac0942eb9_167_connectSerialPortByIndex)
HXLINE( 168)		if (::hx::IsNotNull( this->serialObj )) {
HXLINE( 169)			if (this->serialObj->isSetup) {
HXLINE( 170)				this->serialObj->close();
            			}
            		}
HXLINE( 174)		this->deviceList = ::hxSerial::Serial_obj::getDeviceList();
HXLINE( 176)		bool _hx_tmp;
HXDLIN( 176)		if ((i >= 0)) {
HXLINE( 176)			_hx_tmp = (i < this->deviceList->length);
            		}
            		else {
HXLINE( 176)			_hx_tmp = false;
            		}
HXDLIN( 176)		if (_hx_tmp) {
HXLINE( 177)			this->serialObj =  ::hxSerial::Serial_obj::__alloc( HX_CTX ,this->deviceList->__get(i),115200,true);
HXLINE( 178)			this->statusText->set_text((HX_("connected to ",6e,b5,19,b6) + this->serialObj->portName));
HXLINE( 179)			this->serialConnected = true;
HXLINE( 180)			this->serialPortIndex = i;
            		}
            		else {
HXLINE( 182)			this->statusText->set_text(((HX_("SerialPort index ",d9,55,ad,ad) + i) + HX_(" is not available",e6,b1,3f,b4)));
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC1(Main_obj,connectSerialPortByIndex,(void))

void Main_obj::connectSerialPortByPath(::String devicePath){
            	HX_GC_STACKFRAME(&_hx_pos_e47a9afac0942eb9_190_connectSerialPortByPath)
HXLINE( 191)		if (::hx::IsNotNull( this->serialObj )) {
HXLINE( 192)			if (this->serialObj->isSetup) {
HXLINE( 193)				this->serialObj->close();
            			}
            		}
HXLINE( 197)		this->deviceList = ::hxSerial::Serial_obj::getDeviceList();
HXLINE( 198)		this->serialPortIndex = this->deviceList->indexOf(devicePath,null());
HXLINE( 199)		if ((this->serialPortIndex != -1)) {
HXLINE( 200)			this->serialObj =  ::hxSerial::Serial_obj::__alloc( HX_CTX ,this->deviceList->__get(this->serialPortIndex),115200,true);
HXLINE( 201)			this->statusText->set_text((HX_("connected to ",6e,b5,19,b6) + this->serialObj->portName));
HXLINE( 202)			this->serialConnected = true;
            		}
            		else {
HXLINE( 204)			this->statusText->set_text(((HX_("SerialPort ",cb,96,a0,54) + devicePath) + HX_(" is not available",e6,b1,3f,b4)));
HXLINE( 205)			::haxe::Log_obj::trace(((HX_("SerialPort ",cb,96,a0,54) + devicePath) + HX_(" is not available",e6,b1,3f,b4)),::hx::SourceInfo(HX_("Source/Main.hx",b1,67,fd,ea),205,HX_("Main",59,64,2f,33),HX_("connectSerialPortByPath",9b,a0,7f,0c)));
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC1(Main_obj,connectSerialPortByPath,(void))

void Main_obj::nextPort(){
            	HX_STACKFRAME(&_hx_pos_e47a9afac0942eb9_213_nextPort)
HXDLIN( 213)		if (::hx::IsNotNull( this->deviceList )) {
HXLINE( 214)			if ((this->serialPortIndex < (this->deviceList->length - 2))) {
HXLINE( 215)				this->connectSerialPortByIndex((this->serialPortIndex + 1));
            			}
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC0(Main_obj,nextPort,(void))

void Main_obj::previousPort(){
            	HX_STACKFRAME(&_hx_pos_e47a9afac0942eb9_224_previousPort)
HXDLIN( 224)		if (::hx::IsNotNull( this->deviceList )) {
HXLINE( 225)			if ((this->serialPortIndex > 0)) {
HXLINE( 226)				this->connectSerialPortByIndex((this->serialPortIndex - 1));
            			}
            			else {
HXLINE( 228)				this->connectSerialPortByIndex(0);
            			}
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC0(Main_obj,previousPort,(void))

void Main_obj::parseSerial(){
            	HX_STACKFRAME(&_hx_pos_e47a9afac0942eb9_238_parseSerial)
HXDLIN( 238)		if (this->serialConnected) {
HXLINE( 239)			int bytesAvailable = this->serialObj->available();
HXLINE( 240)			if ((bytesAvailable > 0)) {
HXLINE( 241)				 ::Main _hx_tmp = ::hx::ObjectPtr<OBJ_>(this);
HXDLIN( 241)				::String _hx_tmp1 = _hx_tmp->serialBuffer;
HXDLIN( 241)				_hx_tmp->serialBuffer = (_hx_tmp1 + this->serialObj->readBytes(bytesAvailable).toString());
HXLINE( 244)				::StringTools_obj::replace(this->serialBuffer,HX_("\r",0d,00,00,00),HX_("",00,00,00,00));
HXLINE( 247)				if ((this->serialBuffer.indexOf(HX_("\n",0a,00,00,00),null()) != -1)) {
HXLINE( 249)					int noBytesAfterNewline = this->serialBuffer.lastIndexOf(HX_("\n",0a,00,00,00),null());
HXDLIN( 249)					bool noBytesAfterNewline1 = (noBytesAfterNewline == (this->serialBuffer.length - 1));
HXLINE( 252)					::Array< ::String > lines = this->serialBuffer.split(HX_("\n",0a,00,00,00));
HXLINE( 255)					this->serialLine = ::StringTools_obj::trim(lines->__get(0));
HXLINE( 257)					this->playVideoByTag(this->serialLine);
            				}
            			}
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC0(Main_obj,parseSerial,(void))

void Main_obj::playVideoByTag(::String tag){
            	HX_STACKFRAME(&_hx_pos_e47a9afac0942eb9_266_playVideoByTag)
HXLINE( 267)		bool _hx_tmp;
HXDLIN( 267)		if (::controllers::DataController_obj::waitUntilVideoFinished) {
HXLINE( 267)			_hx_tmp = this->video->get_isPlaying();
            		}
            		else {
HXLINE( 267)			_hx_tmp = false;
            		}
HXDLIN( 267)		if (_hx_tmp) {
HXLINE( 268)			return;
            		}
HXLINE( 270)		bool _hx_tmp1;
HXDLIN( 270)		if (!(::controllers::DataController_obj::retriggerTag)) {
HXLINE( 270)			_hx_tmp1 = (tag == this->currentTag);
            		}
            		else {
HXLINE( 270)			_hx_tmp1 = false;
            		}
HXDLIN( 270)		if (_hx_tmp1) {
HXLINE( 271)			return;
            		}
HXLINE( 273)		tag = tag.toUpperCase();
HXLINE( 274)		int millies = ::lime::_hx_system::System_obj::getTimer();
HXLINE( 275)		if (((millies - this->tagStartTime) < this->tagTriggerDebounce)) {
HXLINE( 276)			::haxe::Log_obj::trace(HX_(" not ready to triger yet.",82,be,39,52),::hx::SourceInfo(HX_("Source/Main.hx",b1,67,fd,ea),276,HX_("Main",59,64,2f,33),HX_("playVideoByTag",5c,a5,b1,fb)));
HXLINE( 277)			return;
            		}
HXLINE( 279)		if (::controllers::DataController_obj::videoTags->exists(tag)) {
HXLINE( 280)			this->statusText->set_text((HX_("starting video ",a5,65,60,db) + tag));
HXLINE( 281)			 ::hxvlc::openfl::Video _hx_tmp2 = this->video;
HXDLIN( 281)			_hx_tmp2->load(::controllers::DataController_obj::videoTags->get(tag),null());
HXLINE( 282)			this->video->play();
HXLINE( 283)			this->tagStartTime = millies;
            		}
            		else {
HXLINE( 285)			this->statusText->set_text((HX_("no such tagged video ",df,f0,2e,c4) + tag));
HXLINE( 286)			this->tagStartTime = millies;
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC1(Main_obj,playVideoByTag,(void))


::hx::ObjectPtr< Main_obj > Main_obj::__new() {
	::hx::ObjectPtr< Main_obj > __this = new Main_obj();
	__this->__construct();
	return __this;
}

::hx::ObjectPtr< Main_obj > Main_obj::__alloc(::hx::Ctx *_hx_ctx) {
	Main_obj *__this = (Main_obj*)(::hx::Ctx::alloc(_hx_ctx, sizeof(Main_obj), true, "Main"));
	*(void **)__this = Main_obj::_hx_vtable;
	__this->__construct();
	return __this;
}

Main_obj::Main_obj()
{
}

void Main_obj::__Mark(HX_MARK_PARAMS)
{
	HX_MARK_BEGIN_CLASS(Main);
	HX_MARK_MEMBER_NAME(serialObj,"serialObj");
	HX_MARK_MEMBER_NAME(deviceList,"deviceList");
	HX_MARK_MEMBER_NAME(storedPortPath,"storedPortPath");
	HX_MARK_MEMBER_NAME(serialConnected,"serialConnected");
	HX_MARK_MEMBER_NAME(serialPortIndex,"serialPortIndex");
	HX_MARK_MEMBER_NAME(serialBuffer,"serialBuffer");
	HX_MARK_MEMBER_NAME(serialLine,"serialLine");
	HX_MARK_MEMBER_NAME(doVideoUpdate,"doVideoUpdate");
	HX_MARK_MEMBER_NAME(tagStartTime,"tagStartTime");
	HX_MARK_MEMBER_NAME(tagTriggerDebounce,"tagTriggerDebounce");
	HX_MARK_MEMBER_NAME(currentTag,"currentTag");
	HX_MARK_MEMBER_NAME(video,"video");
	HX_MARK_MEMBER_NAME(statusText,"statusText");
	HX_MARK_MEMBER_NAME(ffmpegAvailable,"ffmpegAvailable");
	 ::openfl::display::Sprite_obj::__Mark(HX_MARK_ARG);
	HX_MARK_END_CLASS();
}

void Main_obj::__Visit(HX_VISIT_PARAMS)
{
	HX_VISIT_MEMBER_NAME(serialObj,"serialObj");
	HX_VISIT_MEMBER_NAME(deviceList,"deviceList");
	HX_VISIT_MEMBER_NAME(storedPortPath,"storedPortPath");
	HX_VISIT_MEMBER_NAME(serialConnected,"serialConnected");
	HX_VISIT_MEMBER_NAME(serialPortIndex,"serialPortIndex");
	HX_VISIT_MEMBER_NAME(serialBuffer,"serialBuffer");
	HX_VISIT_MEMBER_NAME(serialLine,"serialLine");
	HX_VISIT_MEMBER_NAME(doVideoUpdate,"doVideoUpdate");
	HX_VISIT_MEMBER_NAME(tagStartTime,"tagStartTime");
	HX_VISIT_MEMBER_NAME(tagTriggerDebounce,"tagTriggerDebounce");
	HX_VISIT_MEMBER_NAME(currentTag,"currentTag");
	HX_VISIT_MEMBER_NAME(video,"video");
	HX_VISIT_MEMBER_NAME(statusText,"statusText");
	HX_VISIT_MEMBER_NAME(ffmpegAvailable,"ffmpegAvailable");
	 ::openfl::display::Sprite_obj::__Visit(HX_VISIT_ARG);
}

::hx::Val Main_obj::__Field(const ::String &inName,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 5:
		if (HX_FIELD_EQ(inName,"video") ) { return ::hx::Val( video ); }
		break;
	case 8:
		if (HX_FIELD_EQ(inName,"initText") ) { return ::hx::Val( initText_dyn() ); }
		if (HX_FIELD_EQ(inName,"nextPort") ) { return ::hx::Val( nextPort_dyn() ); }
		break;
	case 9:
		if (HX_FIELD_EQ(inName,"serialObj") ) { return ::hx::Val( serialObj ); }
		if (HX_FIELD_EQ(inName,"initVideo") ) { return ::hx::Val( initVideo_dyn() ); }
		break;
	case 10:
		if (HX_FIELD_EQ(inName,"deviceList") ) { return ::hx::Val( deviceList ); }
		if (HX_FIELD_EQ(inName,"serialLine") ) { return ::hx::Val( serialLine ); }
		if (HX_FIELD_EQ(inName,"currentTag") ) { return ::hx::Val( currentTag ); }
		if (HX_FIELD_EQ(inName,"statusText") ) { return ::hx::Val( statusText ); }
		if (HX_FIELD_EQ(inName,"initSerial") ) { return ::hx::Val( initSerial_dyn() ); }
		break;
	case 11:
		if (HX_FIELD_EQ(inName,"parseSerial") ) { return ::hx::Val( parseSerial_dyn() ); }
		break;
	case 12:
		if (HX_FIELD_EQ(inName,"serialBuffer") ) { return ::hx::Val( serialBuffer ); }
		if (HX_FIELD_EQ(inName,"tagStartTime") ) { return ::hx::Val( tagStartTime ); }
		if (HX_FIELD_EQ(inName,"previousPort") ) { return ::hx::Val( previousPort_dyn() ); }
		break;
	case 13:
		if (HX_FIELD_EQ(inName,"doVideoUpdate") ) { return ::hx::Val( doVideoUpdate ); }
		break;
	case 14:
		if (HX_FIELD_EQ(inName,"storedPortPath") ) { return ::hx::Val( storedPortPath ); }
		if (HX_FIELD_EQ(inName,"playVideoByTag") ) { return ::hx::Val( playVideoByTag_dyn() ); }
		break;
	case 15:
		if (HX_FIELD_EQ(inName,"serialConnected") ) { return ::hx::Val( serialConnected ); }
		if (HX_FIELD_EQ(inName,"serialPortIndex") ) { return ::hx::Val( serialPortIndex ); }
		if (HX_FIELD_EQ(inName,"ffmpegAvailable") ) { return ::hx::Val( ffmpegAvailable ); }
		if (HX_FIELD_EQ(inName,"stage_onKeyDown") ) { return ::hx::Val( stage_onKeyDown_dyn() ); }
		break;
	case 16:
		if (HX_FIELD_EQ(inName,"stage_onActivate") ) { return ::hx::Val( stage_onActivate_dyn() ); }
		break;
	case 18:
		if (HX_FIELD_EQ(inName,"tagTriggerDebounce") ) { return ::hx::Val( tagTriggerDebounce ); }
		if (HX_FIELD_EQ(inName,"stage_onEnterFrame") ) { return ::hx::Val( stage_onEnterFrame_dyn() ); }
		if (HX_FIELD_EQ(inName,"traceSerialDevices") ) { return ::hx::Val( traceSerialDevices_dyn() ); }
		if (HX_FIELD_EQ(inName,"stage_onDeactivate") ) { return ::hx::Val( stage_onDeactivate_dyn() ); }
		break;
	case 23:
		if (HX_FIELD_EQ(inName,"connectSerialPortByPath") ) { return ::hx::Val( connectSerialPortByPath_dyn() ); }
		break;
	case 24:
		if (HX_FIELD_EQ(inName,"connectSerialPortByIndex") ) { return ::hx::Val( connectSerialPortByIndex_dyn() ); }
	}
	return super::__Field(inName,inCallProp);
}

::hx::Val Main_obj::__SetField(const ::String &inName,const ::hx::Val &inValue,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 5:
		if (HX_FIELD_EQ(inName,"video") ) { video=inValue.Cast<  ::hxvlc::openfl::Video >(); return inValue; }
		break;
	case 9:
		if (HX_FIELD_EQ(inName,"serialObj") ) { serialObj=inValue.Cast<  ::hxSerial::Serial >(); return inValue; }
		break;
	case 10:
		if (HX_FIELD_EQ(inName,"deviceList") ) { deviceList=inValue.Cast< ::Array< ::String > >(); return inValue; }
		if (HX_FIELD_EQ(inName,"serialLine") ) { serialLine=inValue.Cast< ::String >(); return inValue; }
		if (HX_FIELD_EQ(inName,"currentTag") ) { currentTag=inValue.Cast< ::String >(); return inValue; }
		if (HX_FIELD_EQ(inName,"statusText") ) { statusText=inValue.Cast<  ::openfl::text::TextField >(); return inValue; }
		break;
	case 12:
		if (HX_FIELD_EQ(inName,"serialBuffer") ) { serialBuffer=inValue.Cast< ::String >(); return inValue; }
		if (HX_FIELD_EQ(inName,"tagStartTime") ) { tagStartTime=inValue.Cast< int >(); return inValue; }
		break;
	case 13:
		if (HX_FIELD_EQ(inName,"doVideoUpdate") ) { doVideoUpdate=inValue.Cast< bool >(); return inValue; }
		break;
	case 14:
		if (HX_FIELD_EQ(inName,"storedPortPath") ) { storedPortPath=inValue.Cast< ::String >(); return inValue; }
		break;
	case 15:
		if (HX_FIELD_EQ(inName,"serialConnected") ) { serialConnected=inValue.Cast< bool >(); return inValue; }
		if (HX_FIELD_EQ(inName,"serialPortIndex") ) { serialPortIndex=inValue.Cast< int >(); return inValue; }
		if (HX_FIELD_EQ(inName,"ffmpegAvailable") ) { ffmpegAvailable=inValue.Cast< bool >(); return inValue; }
		break;
	case 18:
		if (HX_FIELD_EQ(inName,"tagTriggerDebounce") ) { tagTriggerDebounce=inValue.Cast< int >(); return inValue; }
	}
	return super::__SetField(inName,inValue,inCallProp);
}

void Main_obj::__GetFields(Array< ::String> &outFields)
{
	outFields->push(HX_("serialObj",63,8e,de,f4));
	outFields->push(HX_("deviceList",14,28,3d,b1));
	outFields->push(HX_("storedPortPath",49,92,b7,b3));
	outFields->push(HX_("serialConnected",35,7a,21,fb));
	outFields->push(HX_("serialPortIndex",3d,cb,de,a5));
	outFields->push(HX_("serialBuffer",14,8a,40,c3));
	outFields->push(HX_("serialLine",08,b8,e7,4b));
	outFields->push(HX_("doVideoUpdate",19,43,11,a5));
	outFields->push(HX_("tagStartTime",d5,af,bd,a4));
	outFields->push(HX_("tagTriggerDebounce",e7,5f,9e,61));
	outFields->push(HX_("currentTag",a1,1f,33,c7));
	outFields->push(HX_("video",7b,14,fc,36));
	outFields->push(HX_("statusText",ff,60,57,b1));
	outFields->push(HX_("ffmpegAvailable",44,09,13,b3));
	super::__GetFields(outFields);
};

#ifdef HXCPP_SCRIPTABLE
static ::hx::StorageInfo Main_obj_sMemberStorageInfo[] = {
	{::hx::fsObject /*  ::hxSerial::Serial */ ,(int)offsetof(Main_obj,serialObj),HX_("serialObj",63,8e,de,f4)},
	{::hx::fsObject /* ::Array< ::String > */ ,(int)offsetof(Main_obj,deviceList),HX_("deviceList",14,28,3d,b1)},
	{::hx::fsString,(int)offsetof(Main_obj,storedPortPath),HX_("storedPortPath",49,92,b7,b3)},
	{::hx::fsBool,(int)offsetof(Main_obj,serialConnected),HX_("serialConnected",35,7a,21,fb)},
	{::hx::fsInt,(int)offsetof(Main_obj,serialPortIndex),HX_("serialPortIndex",3d,cb,de,a5)},
	{::hx::fsString,(int)offsetof(Main_obj,serialBuffer),HX_("serialBuffer",14,8a,40,c3)},
	{::hx::fsString,(int)offsetof(Main_obj,serialLine),HX_("serialLine",08,b8,e7,4b)},
	{::hx::fsBool,(int)offsetof(Main_obj,doVideoUpdate),HX_("doVideoUpdate",19,43,11,a5)},
	{::hx::fsInt,(int)offsetof(Main_obj,tagStartTime),HX_("tagStartTime",d5,af,bd,a4)},
	{::hx::fsInt,(int)offsetof(Main_obj,tagTriggerDebounce),HX_("tagTriggerDebounce",e7,5f,9e,61)},
	{::hx::fsString,(int)offsetof(Main_obj,currentTag),HX_("currentTag",a1,1f,33,c7)},
	{::hx::fsObject /*  ::hxvlc::openfl::Video */ ,(int)offsetof(Main_obj,video),HX_("video",7b,14,fc,36)},
	{::hx::fsObject /*  ::openfl::text::TextField */ ,(int)offsetof(Main_obj,statusText),HX_("statusText",ff,60,57,b1)},
	{::hx::fsBool,(int)offsetof(Main_obj,ffmpegAvailable),HX_("ffmpegAvailable",44,09,13,b3)},
	{ ::hx::fsUnknown, 0, null()}
};
static ::hx::StaticInfo *Main_obj_sStaticStorageInfo = 0;
#endif

static ::String Main_obj_sMemberFields[] = {
	HX_("serialObj",63,8e,de,f4),
	HX_("deviceList",14,28,3d,b1),
	HX_("storedPortPath",49,92,b7,b3),
	HX_("serialConnected",35,7a,21,fb),
	HX_("serialPortIndex",3d,cb,de,a5),
	HX_("serialBuffer",14,8a,40,c3),
	HX_("serialLine",08,b8,e7,4b),
	HX_("doVideoUpdate",19,43,11,a5),
	HX_("tagStartTime",d5,af,bd,a4),
	HX_("tagTriggerDebounce",e7,5f,9e,61),
	HX_("currentTag",a1,1f,33,c7),
	HX_("video",7b,14,fc,36),
	HX_("statusText",ff,60,57,b1),
	HX_("ffmpegAvailable",44,09,13,b3),
	HX_("initSerial",24,c5,72,72),
	HX_("initText",dd,fb,b0,51),
	HX_("initVideo",4b,2f,8e,52),
	HX_("stage_onEnterFrame",55,6f,40,8f),
	HX_("stage_onKeyDown",41,22,dc,ac),
	HX_("traceSerialDevices",c4,1d,cd,0d),
	HX_("stage_onActivate",13,ef,38,57),
	HX_("stage_onDeactivate",94,c7,f1,c8),
	HX_("connectSerialPortByIndex",5c,77,ea,e3),
	HX_("connectSerialPortByPath",9b,a0,7f,0c),
	HX_("nextPort",14,2a,29,f6),
	HX_("previousPort",58,53,fe,f0),
	HX_("parseSerial",87,16,6a,e9),
	HX_("playVideoByTag",5c,a5,b1,fb),
	::String(null()) };

::hx::Class Main_obj::__mClass;

void Main_obj::__register()
{
	Main_obj _hx_dummy;
	Main_obj::_hx_vtable = *(void **)&_hx_dummy;
	::hx::Static(__mClass) = new ::hx::Class_obj();
	__mClass->mName = HX_("Main",59,64,2f,33);
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &::hx::Class_obj::GetNoStaticField;
	__mClass->mSetStaticField = &::hx::Class_obj::SetNoStaticField;
	__mClass->mStatics = ::hx::Class_obj::dupFunctions(0 /* sStaticFields */);
	__mClass->mMembers = ::hx::Class_obj::dupFunctions(Main_obj_sMemberFields);
	__mClass->mCanCast = ::hx::TCanCast< Main_obj >;
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = Main_obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = Main_obj_sStaticStorageInfo;
#endif
	::hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

