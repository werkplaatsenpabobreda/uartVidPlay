// Generated by Haxe 4.3.7
#include <hxcpp.h>

#ifndef INCLUDED_841f8144160e16b7
#define INCLUDED_841f8144160e16b7
#include "stdarg.h"
#endif
#ifndef INCLUDED_2710e462964f946c
#define INCLUDED_2710e462964f946c
#include "stdlib.h"
#endif
#ifndef INCLUDED_f6e4a6bd16e728f7
#define INCLUDED_f6e4a6bd16e728f7
#include "vlc/vlc.h"
#endif
#ifndef INCLUDED_haxe_Exception
#include <haxe/Exception.h>
#endif
#ifndef INCLUDED_haxe_Log
#include <haxe/Log.h>
#endif
#ifndef INCLUDED_haxe_io_BytesInput
#include <haxe/io/BytesInput.h>
#endif
#ifndef INCLUDED_haxe_io_Input
#include <haxe/io/Input.h>
#endif
#ifndef INCLUDED_haxe_io_Path
#include <haxe/io/Path.h>
#endif
#ifndef INCLUDED_hxvlc_util_Util
#include <hxvlc/util/Util.h>
#endif
#ifndef INCLUDED_sys_FileSystem
#include <sys/FileSystem.h>
#endif

HX_LOCAL_STACK_FRAME(_hx_pos_c5a92157c0ab85c2_100_mkDirs,"hxvlc.util.Util","mkDirs",0x0b054595,"hxvlc.util.Util.mkDirs","hxvlc/util/Util.hx",100,0x5727bac1)
HX_LOCAL_STACK_FRAME(_hx_pos_c5a92157c0ab85c2_160_normalizePath,"hxvlc.util.Util","normalizePath",0x88ab6b61,"hxvlc.util.Util.normalizePath","hxvlc/util/Util.hx",160,0x5727bac1)
HX_LOCAL_STACK_FRAME(_hx_pos_c5a92157c0ab85c2_175_convertAbsToURL,"hxvlc.util.Util","convertAbsToURL",0x4856e144,"hxvlc.util.Util.convertAbsToURL","hxvlc/util/Util.hx",175,0x5727bac1)
HX_LOCAL_STACK_FRAME(_hx_pos_c5a92157c0ab85c2_188_readFromInput,"hxvlc.util.Util","readFromInput",0x900cff99,"hxvlc.util.Util.readFromInput","hxvlc/util/Util.hx",188,0x5727bac1)
namespace hxvlc{
namespace util{

void Util_obj::__construct() { }

Dynamic Util_obj::__CreateEmpty() { return new Util_obj; }

void *Util_obj::_hx_vtable = 0;

Dynamic Util_obj::__Create(::hx::DynamicArray inArgs)
{
	::hx::ObjectPtr< Util_obj > _hx_result = new Util_obj();
	_hx_result->__construct();
	return _hx_result;
}

bool Util_obj::_hx_isInstanceOf(int inClassId) {
	return inClassId==(int)0x00000001 || inClassId==(int)0x062d2341;
}

::String Util_obj::getStringFromFormat(const char* fmt, va_list args){
	int len = vsnprintf(nullptr,0,fmt,args);
	if ((len <= 0)) {
		return HX_("",00,00,00,00);
	}
	char* buffer = ( (char*)(malloc((len + 1))) );
	vsnprintf(buffer,(len + 1),fmt,args);
	::String msg = ::String(buffer);
	free(buffer);
	return msg;
}


 ::Dynamic Util_obj::getPosFromContext(const  libvlc_log_t* ctx){
	const char* fileName = nullptr;
	unsigned int lineNumber = ( (unsigned int)(0) );
	const char** _hx_tmp = ::cpp::Pointer_obj::addressOf(fileName)->get_raw();
	libvlc_log_get_context(ctx,nullptr,_hx_tmp,::cpp::Pointer_obj::addressOf(lineNumber)->get_raw());
	::String _hx_tmp1;
	if (::hx::IsNotNull( fileName )) {
		_hx_tmp1 = ::haxe::io::Path_obj::normalize(::String(fileName));
	}
	else {
		_hx_tmp1 = HX_("",00,00,00,00);
	}
	return  ::Dynamic(::hx::Anon_obj::Create(4)
		->setFixed(0,HX_("className",a3,92,3d,dc),HX_("",00,00,00,00))
		->setFixed(1,HX_("methodName",cc,19,0f,12),HX_("",00,00,00,00))
		->setFixed(2,HX_("fileName",e7,5a,43,62),_hx_tmp1)
		->setFixed(3,HX_("lineNumber",dd,81,22,76),( (int)(lineNumber) )));
}


void Util_obj::mkDirs(::String directory){
            	HX_STACKFRAME(&_hx_pos_c5a92157c0ab85c2_100_mkDirs)
HXLINE( 101)		try {
            			HX_STACK_CATCHABLE( ::Dynamic, 0);
HXLINE( 103)			bool _hx_tmp;
HXDLIN( 103)			if (::sys::FileSystem_obj::exists(directory)) {
HXLINE( 103)				_hx_tmp = ::sys::FileSystem_obj::isDirectory(directory);
            			}
            			else {
HXLINE( 103)				_hx_tmp = false;
            			}
HXDLIN( 103)			if (_hx_tmp) {
HXLINE( 104)				return;
            			}
            		} catch( ::Dynamic _hx_e) {
            			if (_hx_e.IsClass<  ::Dynamic >() ){
            				HX_STACK_BEGIN_CATCH
            				 ::Dynamic _g = _hx_e;
HXLINE( 106)				{
HXLINE( 106)					null();
            				}
            			}
            			else {
            				HX_STACK_DO_THROW(_hx_e);
            			}
            		}
HXLINE( 108)		::String total = HX_("",00,00,00,00);
HXLINE( 110)		if ((directory.substr(0,1) == HX_("/",2f,00,00,00))) {
HXLINE( 111)			total = HX_("/",2f,00,00,00);
            		}
HXLINE( 113)		::Array< ::String > parts = directory.split(HX_("/",2f,00,00,00));
HXLINE( 115)		bool _hx_tmp1;
HXDLIN( 115)		if ((parts->length > 0)) {
HXLINE( 115)			_hx_tmp1 = (parts->__get(0).indexOf(HX_(":",3a,00,00,00),null()) > -1);
            		}
            		else {
HXLINE( 115)			_hx_tmp1 = false;
            		}
HXDLIN( 115)		if (_hx_tmp1) {
HXLINE( 116)			parts->shift();
            		}
HXLINE( 118)		{
HXLINE( 118)			int _g1 = 0;
HXDLIN( 118)			while((_g1 < parts->length)){
HXLINE( 118)				::String part = parts->__get(_g1);
HXDLIN( 118)				_g1 = (_g1 + 1);
HXLINE( 120)				bool _hx_tmp2;
HXDLIN( 120)				if ((part != HX_(".",2e,00,00,00))) {
HXLINE( 120)					_hx_tmp2 = (part.length > 0);
            				}
            				else {
HXLINE( 120)					_hx_tmp2 = false;
            				}
HXDLIN( 120)				if (_hx_tmp2) {
HXLINE( 122)					bool _hx_tmp3;
HXDLIN( 122)					if ((total != HX_("/",2f,00,00,00))) {
HXLINE( 122)						_hx_tmp3 = (total.length > 0);
            					}
            					else {
HXLINE( 122)						_hx_tmp3 = false;
            					}
HXDLIN( 122)					if (_hx_tmp3) {
HXLINE( 123)						total = (total + HX_("/",2f,00,00,00));
            					}
HXLINE( 125)					total = (total + part);
HXLINE( 127)					try {
            						HX_STACK_CATCHABLE( ::Dynamic, 0);
HXLINE( 129)						bool _hx_tmp4;
HXDLIN( 129)						if (::sys::FileSystem_obj::exists(total)) {
HXLINE( 129)							_hx_tmp4 = !(::sys::FileSystem_obj::isDirectory(total));
            						}
            						else {
HXLINE( 129)							_hx_tmp4 = false;
            						}
HXDLIN( 129)						if (_hx_tmp4) {
HXLINE( 130)							::sys::FileSystem_obj::deleteFile(total);
            						}
HXLINE( 132)						if (!(::sys::FileSystem_obj::exists(total))) {
HXLINE( 133)							::sys::FileSystem_obj::createDirectory(total);
            						}
            					} catch( ::Dynamic _hx_e) {
            						if (_hx_e.IsClass<  ::Dynamic >() ){
            							HX_STACK_BEGIN_CATCH
            							 ::Dynamic _g2 = _hx_e;
HXLINE( 135)							 ::haxe::Exception e = ::haxe::Exception_obj::caught(_g2);
HXLINE( 137)							 ::Dynamic _hx_tmp5 = ::haxe::Log_obj::trace;
HXDLIN( 137)							::String _hx_tmp6 = (((HX_("Failed to create \"",80,b2,52,c7) + total) + HX_("\" directory, ",23,ad,b6,dc)) + e->get_message());
HXDLIN( 137)							_hx_tmp5(_hx_tmp6,::hx::SourceInfo(HX_("hxvlc/util/Util.hx",c1,ba,27,57),137,HX_("hxvlc.util.Util",bd,ab,58,53),HX_("mkDirs",04,f9,08,5e)));
HXLINE( 139)							goto _hx_goto_0;
            						}
            						else {
            							HX_STACK_DO_THROW(_hx_e);
            						}
            					}
            				}
            			}
            			_hx_goto_0:;
            		}
            	}


::String Util_obj::normalizePath(::String location){
            	HX_STACKFRAME(&_hx_pos_c5a92157c0ab85c2_160_normalizePath)
HXDLIN( 160)		return ::haxe::io::Path_obj::normalize(location);
            	}


::String Util_obj::convertAbsToURL(::String path){
            	HX_STACKFRAME(&_hx_pos_c5a92157c0ab85c2_175_convertAbsToURL)
HXDLIN( 175)		return (HX_("file://",de,92,3b,ff) + ::haxe::io::Path_obj::normalize(::sys::FileSystem_obj::absolutePath(path)));
            	}


int Util_obj::readFromInput( ::haxe::io::BytesInput input,::cpp::Pointer< unsigned char > buf,int len){
            	HX_STACKFRAME(&_hx_pos_c5a92157c0ab85c2_188_readFromInput)
HXLINE( 189)		if ((input->pos >= input->totlen)) {
HXLINE( 190)			return 0;
            		}
HXLINE( 192)		int remaining = (input->totlen - input->pos);
HXLINE( 194)		int read;
HXDLIN( 194)		if ((len < remaining)) {
HXLINE( 194)			read = len;
            		}
            		else {
HXLINE( 194)			read = remaining;
            		}
HXLINE( 196)		bool _hx_tmp;
HXDLIN( 196)		if ((input->pos <= (input->totlen - read))) {
HXLINE( 196)			_hx_tmp = ::hx::IsNull( input->b );
            		}
            		else {
HXLINE( 196)			_hx_tmp = true;
            		}
HXDLIN( 196)		if (_hx_tmp) {
HXLINE( 197)			return -1;
            		}
HXLINE( 199)		void* _hx_tmp1 = ( (void*)(buf->get_raw()) );
HXDLIN( 199)		memcpy(_hx_tmp1,( (const void*)(::cpp::Pointer_obj::addressOf(( ( ::cpp::ArrayBase)(input->b) )->getBase()[input->pos])->get_constRaw()) ),read);
HXLINE( 201)		input->set_position((input->pos + read));
HXLINE( 203)		return read;
            	}



Util_obj::Util_obj()
{
}

#ifdef HXCPP_SCRIPTABLE
static ::hx::StorageInfo *Util_obj_sMemberStorageInfo = 0;
static ::hx::StaticInfo *Util_obj_sStaticStorageInfo = 0;
#endif

::hx::Class Util_obj::__mClass;

void Util_obj::__register()
{
	Util_obj _hx_dummy;
	Util_obj::_hx_vtable = *(void **)&_hx_dummy;
	::hx::Static(__mClass) = new ::hx::Class_obj();
	__mClass->mName = HX_("hxvlc.util.Util",bd,ab,58,53);
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &::hx::Class_obj::GetNoStaticField;
	__mClass->mSetStaticField = &::hx::Class_obj::SetNoStaticField;
	__mClass->mStatics = ::hx::Class_obj::dupFunctions(0 /* sStaticFields */);
	__mClass->mMembers = ::hx::Class_obj::dupFunctions(0 /* sMemberFields */);
	__mClass->mCanCast = ::hx::TCanCast< Util_obj >;
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = Util_obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = Util_obj_sStaticStorageInfo;
#endif
	::hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

} // end namespace hxvlc
} // end namespace util
